#include <stdint.h>
#include <string.h>
#include <stdint.h>
#include "drivers/memlayout.h"
#include "drivers/acpi.h"
#include "drivers/lapic.h"
#include "drivers/ps2mouse.h"
#include "drivers/kbd.h"
#include "param.h"
#include "proc.h"
#include "x86.h"
#include "cpu.h"
#include "null.h"
#include "console.h"
#include "kalloc.h"
#include "mp.h"
#include "ioapic.h"
#include "uart.h"
#include "pci.h"
#include "bio.h"
#include "file.h"
#include "ide.h"
#include "vm.h"
#include "picirq.h"
#include "trap.h"
#include "boot/multiboot2.h"
#include "autogenerated/compiler_information.h"
#include "kernel_assert.h"
#include "kernel_ld_syms.h"

static void
startothers(void);
static void
mpmain(void) __attribute__((noreturn));
extern uintptr_t *kpgdir;

uint64_t available_memory;
uint64_t top_memory;


int
main(struct multiboot_info *mbinfo)
{
	/*-----------------------*\
	| uart-only printing zone |
	\*-----------------------*/
	uartinit1(); // serial port
	kinit1(__kernel_end, P2V(4 * 1024 * 1024)); // phys page allocator
	parse_multiboot(mbinfo);
	kernel_assert(available_memory != 0);
	// Past kvmalloc, addresses need to be virtual.
	kvmalloc(); // kernel page table

	/*----------------------------------------------*\
	| We can start printing to the framebuffer here. |
	\*----------------------------------------------*/

	ioapicinit(); // another interrupt controller
	uartinit2();
	vga_cprintf("relix (built with %s and linker %s)\n", RELIX_COMPILER, RELIX_LINKER);
	if (acpiinit() != 0)
		mpinit(); // detect other processors
	lapicinit(); // interrupt controller
	seginit(); // segment descriptors
	picinit(); // disable pic
	kbdinit();
	// /dev/console, not to be confused with VGA memory
	consoleinit(); // console hardware
	nulldrvinit();
	pinit(); // process table
	tvinit(); // trap vectors
	block_init(); // buffer cache
	fileinit(); // file table
	ideinit(); // disk
	ps2mouseinit();
	//timerinit();
	pci_init();
	startothers(); // start other processors
	kinit2(P2V(4UL * 1024 * 1024), P2V(available_memory)); // must come after startothers()
	userinit(); // first user process
	mpmain(); // finish this processor's setup
}

// Other CPUs jump here from entryother.S.
void
mpenter(void)
{
	switchkvm();
	seginit();
	lapicinit();
	mpmain();
}

// Common CPU setup code.
static void
mpmain(void)
{
	vga_cprintf("\033[97;44mcpu%d: starting\033[m\n", my_cpu_id());
	idtinit(); // load idt register
	cpu_features_init();
	xchg(&(mycpu()->started), 1); // tell startothers() we're up
	scheduler(); // start running processes
}

void
entry32mp(void);

// Start the non-boot (AP) processors.
static void
startothers(void)
{
	/* very strange:
  * the value of this var is determined by the linker. It needs to be the full directory.
  * _binary_[file_path]_start
  * */
	extern uint8_t _binary_bin_entryother_start[], _binary_bin_entryother_size[];
	uint8_t *code;
	struct cpu *c;
	char *stack;

	struct {
		uint64_t s3;
		uint32_t s2;
		uint32_t s1;
	} intro_stack;

	// Write entry code to unused memory at 0x7000.
	// The linker has placed the image of entryother.S in
	// _binary_entryother_start.
	// Subtract sizeof(intro_stack) because
	// we need to store data below this.
	code = p2v(0x7000) - sizeof(intro_stack);
	memmove(code + sizeof(intro_stack), _binary_bin_entryother_start,
					(uintptr_t)_binary_bin_entryother_size);

	for (c = cpus; c < cpus + ncpu; c++) {
		if (c == mycpu()) // We've started already.
			continue;

		// Tell entryother.S what stack to use, where to enter, and what
		// pgdir to use. We cannot use kpgdir yet, because the AP processor
		// is running in low  memory, so we use entrypgdir for the APs too.
		stack = kpage_alloc();

		// These are initialized in the order that
		// they are popped off the stack in lapicstartap.
		// In memory, they are in the reverse order due to
		// the stack growing down.
		intro_stack.s1 = 0x8000; // just enough stack to get us to entry64mp
		intro_stack.s2 = v2p(entry32mp);
		intro_stack.s3 = (uint64_t)(stack + KSTACKSIZE);

		memmove(code, &intro_stack, sizeof(intro_stack));
		// Put code pointer at the top of the stack.
		code += sizeof(intro_stack);

		lapicstartap(c->apicid, v2p(code));

		// wait for cpu to finish mpmain()
		while (c->started == 0)
			;
	}
}
