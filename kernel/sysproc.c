#include "autogenerated/compiler_information.h"

#include "dev/hpet.h"
#include "dev/lapic.h"

#include "console.h"
#include "kernel_ld_syms.h"
#include "kernel_signal.h"
#include "proc.h"
#include "syscall.h"
#include "time_units.h"
#include "trap.h"
#include "x86.h"

#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdint.h>
#include <string.h>
#include <sys/reboot.h>
#include <sys/times.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <time.h>

size_t
sys_fork(void)
{
	return fork();
}

size_t
sys__exit(void)
{
	int status;
	PROPOGATE_ERR(argint(0, &status));

	exit(status);
	return 0; // not reached
}

size_t
sys_waitpid(void)
{
	pid_t pid;
	int *status;
	int options;
	PROPOGATE_ERR(argpid_t(0, &pid));
	PROPOGATE_ERR(argptr(1, (char **)&status, sizeof(*status)));
	PROPOGATE_ERR(argint(2, &options));

	if (options != 0 && options != WNOHANG && options != WCONTINUED &&
	    options != WSTOPPED) {
		return -EINVAL;
	}
	if (options != 0) {
		return -ENOSYS;
	}
	return waitpid(pid, status, options);
}

size_t
sys_kill(void)
{
	pid_t pid;
	int signal;

	PROPOGATE_ERR(argpid_t(0, &pid));
	PROPOGATE_ERR(argint(1, &signal));

	return kill(pid, signal);
}

size_t
sys_getpid(void)
{
	return myproc()->pid;
}

size_t
sys_getppid(void)
{
	struct proc *proc = myproc();
	if (proc != NULL && proc->parent != NULL) {
		return proc->parent->pid;
	} else {
		// If parent has been killed, use init (PID 1).
		return 1;
	}
}

size_t
sys_sbrk(void)
{
	uintptr_t addr;
	intptr_t n;

	PROPOGATE_ERR(argintptr_t(0, &n));

	addr = myproc()->sz;
	PROPOGATE_ERR(growproc(n));
	return addr;
}

size_t
sys_alarm(void)
{
	unsigned int n;
	time_t ticks0;

	PROPOGATE_ERR(argunsigned_int(0, &n));

	// Convert seconds to milliseconds.
	n *= 1000;
	acquire(&tickslock);
	ticks0 = ticks;
	while (ticks - ticks0 < n) {
		if (myproc()->killed) {
			release(&tickslock);
			return -ESRCH;
		}
		sleep(&ticks, &tickslock);
	}
	kill(myproc()->pid, SIGALRM);
	release(&tickslock);
	return 0;
}

// return how many clock tick interrupts have occurred
// since start.
size_t
sys_uptime(void)
{
	time_t xticks;

	xticks = ticks;
	return xticks;
}

size_t
sys_clock_nanosleep(void)
{
	clockid_t clockid;
	int flags;
	struct timespec *duration;
	struct timespec *rem;

	PROPOGATE_ERR(argclockid_t(0, &clockid));
	PROPOGATE_ERR(argint(1, &flags));
	PROPOGATE_ERR(argptr(2, (char **)&duration, sizeof(*duration)));
	PROPOGATE_ERR(argptr(3, (char **)&rem, sizeof(*rem)));

	if (duration == NULL && (uintptr_t)duration >= (uintptr_t)__kernel_begin) {
		return -EFAULT;
	}
	if (clockid != CLOCK_REALTIME) {
		return -ENOSYS;
	}

	if (flags & ~(TIMER_ABSTIME)) {
		return -EINVAL;
	}

	long n = duration->tv_nsec;
	if (n < 0 || n > 9999999999) {
		return -EINVAL;
	}

	// We just validated above that n is non-negative, so this is
	// a safe conversion.
	time_t nseconds = (time_t)n + duration->tv_sec * NSEC_PER_SEC;
	hpet_timer_set_ns(hpet_get_timer_n(0), nseconds);

	// We do a sleep-wakeup loop. The other side is in trap.c.
	hpet_waiting = true;

	acquire(&hpet_lock);
	sleep(&hpet_waiting, &hpet_lock);
	if (myproc()->killed) {
		release(&hpet_lock);
		return -ESRCH;
	}
	release(&hpet_lock);
	return 0;
}

size_t
sys_clock_gettime(void)
{
	clockid_t clockid;
	struct timespec *tp;
	PROPOGATE_ERR(argclockid_t(0, &clockid));
	PROPOGATE_ERR(argptr(1, (char **)&tp, sizeof(*tp)));

	if (tp == NULL || (uintptr_t)tp >= (uintptr_t)__kernel_begin) {
		return -EFAULT;
	}
	if (clockid != CLOCK_MONOTONIC) {
		return -ENOSYS;
	}
	*tp = (struct timespec){ rtc_now(), 0 };
	return 0;
}

static void __attribute__((noreturn))
poweroff(void)
{
	// get rid of init
	kill(0, SIGKILL);
	kill(1, SIGKILL);
	// shut down qemu through magic acpi numbers
	outw(0xB004, 0x0 | 0x2000);
	outw(0x604, 0x0 | 0x2000);
	// get rid of "noreturn" warning
	panic("Unreachable.");
}

size_t
sys_reboot(void)
{
	int cmd;
	PROPOGATE_ERR(argint(0, &cmd));

	switch (cmd) {
	case RB_POWER_OFF:
		kill(1, SIGKILL);
		cprintf("Shutting down.\n");
		poweroff();
		/* unreachable */
		return 0;
		break;
	case RB_HALT:
		kill(1, SIGKILL);
		cprintf("System Halted.\n");
		cli();
		hlt();
		/* unreachable */
		return 0;
		break;
	default:
		return -EINVAL;
	}
}

size_t
sys_setgid(void)
{
	// cannot setgid if not root
	if (myproc()->cred.gid != 0) {
		return -EPERM;
	}
	gid_t gid;
	PROPOGATE_ERR(arggid_t(0, &gid));

	myproc()->cred.gid = gid;
	return 0;
}

size_t
sys_setuid(void)
{
	// cannot setuid if not root
	if (myproc()->cred.uid != 0) {
		return -EPERM;
	}
	uid_t uid;
	PROPOGATE_ERR(arguid_t(0, &uid));

	myproc()->cred.uid = uid;
	return 0;
}

size_t
sys_seteuid(void)
{
	// cannot setuid if not root
	if (myproc()->cred.uid != 0) {
		return -EPERM;
	}
	uid_t euid;
	PROPOGATE_ERR(arguid_t(0, &euid));

	myproc()->cred.euid = euid;
	return 0;
}

size_t
sys_setegid(void)
{
	// cannot setuid if not root
	if (myproc()->cred.uid != 0) {
		return -EPERM;
	}
	gid_t egid;
	PROPOGATE_ERR(arggid_t(0, &egid));

	myproc()->cred.egid = egid;
	return 0;
}

size_t
sys_setpgid(void)
{
	pid_t pid;
	pid_t pgid;
	struct proc *proc;
	PROPOGATE_ERR(argpid_t(0, &pid));
	PROPOGATE_ERR(argpid_t(1, &pgid));

	if (pid < 0 || pid >= NPROC) {
		return -EINVAL;
	}
	if (pgid < 0 || pgid >= NPROC) {
		return -EINVAL;
	}
	if (pid == 0) {
		proc = myproc();
		goto got_proc;
	}
	proc = get_process_from_pid(pid);
	if (proc == NULL) {
		return -ESRCH;
	}

got_proc:

	if (pgid == 0) {
		pgid = proc->pid;
	}

	proc->pgid = pgid;
	return 0;
}

size_t
sys_getuid(void)
{
	return myproc()->cred.uid;
}

size_t
sys_geteuid(void)
{
	return myproc()->cred.euid;
}

size_t
sys_getegid(void)
{
	return myproc()->cred.egid;
}

size_t
sys_getgid(void)
{
	return myproc()->cred.gid;
}

size_t
sys_getpgid(void)
{
	struct proc *proc;
	pid_t pid;

	PROPOGATE_ERR(argpid_t(0, &pid));

	if (pid < 0 || pid >= NPROC) {
		return -EINVAL;
	}
	if (pid == 0) {
		proc = myproc();
		goto got_proc;
	}
	proc = get_process_from_pid(pid);
	if (proc == NULL) {
		return -ESRCH;
	}

got_proc:
	return proc->pgid;
}

size_t
sys_setsid(void)
{
	struct proc *proc = myproc();
	// We cannot create a new session if the
	// calling process is a process group leader
	// (which is determined from pid == pgid).
	if (proc->pid == proc->pgid) {
		return -EPERM;
	}
	proc->sid = proc->pid;
	proc->pgid = proc->pid;
	return proc->sid;
}

size_t
sys_getsid(void)
{
	pid_t pid;
	PROPOGATE_ERR(argpid_t(0, &pid));
	// "If pid is 0, getsid() returns the sesstion ID
	// of the calling process."
	if (pid == 0) {
		struct proc *proc = myproc();
		return proc->sid;
	}

	struct proc *proc = get_process_from_pid(pid);
	if (proc == NULL) {
		return -ESRCH;
	}
	// POSIX makes it implementation-defined whether
	// getsid() returns EPERM in errno if the session ID for
	// process ID `pid` is different than the
	// session ID for the calling process. We will
	// return EPERM.
	if (proc->sid != myproc()->sid) {
		return -EPERM;
	}
	return proc->sid;
}

size_t
sys_ptrace(void)
{
	char *trace_ptr;
	PROPOGATE_ERR(argptr(0, &trace_ptr, SYSCALL_AMT));

	memmove(myproc()->ptrace_mask_ptr, trace_ptr, SYSCALL_AMT);
	return 0;
}

size_t
sys_signal(void)
{
	int signum;
	sighandler_t handler;
	PROPOGATE_ERR(argint(0, &signum));
	PROPOGATE_ERR(argptr(1, (char **)&handler, sizeof(*handler)));

	return (size_t)kernel_attach_signal(signum, handler);
}

size_t
sys_sigprocmask(void)
{
	return -ENOSYS;
}

size_t
sys_sigsuspend(void)
{
	return -ENOSYS;
}
size_t
sys_sigaction(void)
{
	return -ENOSYS;
}

size_t
sys_times(void)
{
	struct tms *tms;
	PROPOGATE_ERR(argptr(0, (char **)&tms, sizeof(*tms)));

	return -ENOSYS;
}

#ifdef __x86_64__
static const char *machine = "x86_64";
#else
static const char *machine = "unknown";
#endif

static int
gethostname(char *name, size_t len)
{
	int fd = vfs_openat(AT_FDCWD, "/etc/hostname", O_RDONLY, 0);
	PROPOGATE_ERR(fd);
	struct file *file = fd_to_struct_file(fd);
	if (file == NULL) {
		return -ENOENT;
	}
	ssize_t ret = vfs_read(file, name, len);
	PROPOGATE_ERR(ret);
	// Get rid of newline.
	name[strlen(name) - 1] = '\0';

	return vfs_close(file);
}

size_t
sys_uname(void)
{
	struct utsname *utsname;
	PROPOGATE_ERR(argptr(0, (char **)&utsname, sizeof(*utsname)));
	if (utsname == NULL) {
		return -EFAULT;
	}
	strncpy(utsname->machine, machine, _UTSNAME_LEN);
	strncpy(utsname->release, RELIX_RELEASE, _UTSNAME_LEN);
	strncpy(utsname->version, RELIX_VERSION, _UTSNAME_LEN);
	strncpy(utsname->sysname, "Relix", _UTSNAME_LEN);
	char hostname[HOST_NAME_MAX] = {};
	int ret = gethostname(hostname, HOST_NAME_MAX);
	PROPOGATE_ERR(ret);
	strncpy(utsname->nodename, hostname, sizeof(utsname->nodename));
	utsname->nodename[sizeof(utsname->nodename) - 1] = '\0';
	return 0;
}

size_t
sys_getgroups(void)
{
	int gidsetsize;
	int ngroups = 0;
	gid_t *grouplist;
	bool copying = true;
	PROPOGATE_ERR(argint(0, &gidsetsize));
	// If gidsetsize is 0, getgroups() shall return the number of group IDs that
	// it would otherwise return without modifying the array pointed to by
	// grouplist.
	if (gidsetsize == 0) {
		copying = false;
		// POSIX.1-2024: "If the effective group ID of the process is returned with
		// the supplementary group IDs, the value returned shall always be greater
		// than or equal to one and less than or equal to the value of
		// {NGROUPS_MAX}+1."
		//
		// Note that our implementation does not return egid. POSIX does not specify
		// whether or not this changes the bounds of gidgetsize, however.
	} else if (!(1 <= gidsetsize && gidsetsize <= NGROUPS_MAX + 1)) {
		return -EINVAL;
	}
	PROPOGATE_ERR(argptr(2, (char **)&grouplist, sizeof(gid_t) * gidsetsize));
	struct proc *curproc = myproc();
	for (; ngroups < gidsetsize; ngroups++) {
		// -1 happens to be our indication for an invalid group. We
		// can use this to know where the end of the groups are.
		if (curproc->cred.gids[ngroups] == (gid_t)-1) {
			break;
		}
		if (copying) {
			grouplist[ngroups] = curproc->cred.gids[ngroups];
		}
	}
	return ngroups;
}
