diff --git a/doomgeneric/doomgeneric_relix.c b/doomgeneric/doomgeneric_relix.c
new file mode 100644
index 0000000..a862c6f
--- /dev/null
+++ b/doomgeneric/doomgeneric_relix.c
@@ -0,0 +1,239 @@
+
+#include "doomkeys.h"
+#include "m_argv.h"
+#include "doomgeneric.h"
+
+#include "ext.h"
+#include "userspace/include/gui.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <termios.h>
+
+#include <stdbool.h>
+
+#define KEYQUEUE_SIZE 16
+
+static unsigned short s_KeyQueue[KEYQUEUE_SIZE];
+static unsigned int s_KeyQueueWriteIndex = 0;
+static unsigned int s_KeyQueueReadIndex = 0;
+
+static time_t time_since_start = 0;
+static void *fb;
+static int fd = -1;
+
+static void
+echo_off(void);
+
+static unsigned char keycode_to_doom_key(unsigned char scancode)
+{
+    unsigned char key = 0;
+
+    switch (scancode)
+    {
+		case 15:
+			key = KEY_TAB;
+			break;
+		case 11:
+			key = '0';
+			break;
+		case 2:
+			key = '1';
+			break;
+		case 3:
+			key = '2';
+			break;
+		case 4:
+			key = '3';
+			break;
+		case 5:
+			key = '4';
+			break;
+		case 6:
+			key = '5';
+			break;
+		case 7:
+			key = '6';
+			break;
+		case 8:
+			key = '7';
+			break;
+		case 9:
+			key = '8';
+			break;
+		case 10:
+			key = '9';
+			break;
+    case 0x9C:
+    case 0x1C:
+        key = KEY_ENTER;
+        break;
+    case 0x01:
+        key = KEY_ESCAPE;
+        break;
+    case 0xCB:
+    case 0x4B:
+        key = KEY_LEFTARROW;
+        break;
+    case 0xCD:
+    case 0x4D:
+        key = KEY_RIGHTARROW;
+        break;
+    case 0xC8:
+    case 0x48:
+        key = KEY_UPARROW;
+        break;
+    case 0xD0:
+    case 0x50:
+        key = KEY_DOWNARROW;
+        break;
+    case 0x1D:
+        key = KEY_FIRE;
+        break;
+    case 0x39:
+        key = KEY_USE;
+        break;
+    case 0x2A:
+    case 0x36:
+        key = KEY_RSHIFT;
+        break;
+    case 0x15:
+        key = 'y';
+    default:
+        break;
+    }
+
+    return key;
+}
+
+static void
+add_key_to_queue(int pressed, unsigned char keycode)
+{
+	unsigned char key = keycode_to_doom_key(keycode);
+
+	unsigned short keyData = (pressed << 8) | key;
+
+	s_KeyQueue[s_KeyQueueWriteIndex] = keyData;
+	s_KeyQueueWriteIndex++;
+	s_KeyQueueWriteIndex %= KEYQUEUE_SIZE;
+}
+
+void
+DG_Init()
+{
+	time_since_start = uptime();
+	fd = open("/dev/kbd0", O_RDONLY | O_NONBLOCK);
+	if (fd < 0) {
+		perror("open");
+		exit(EXIT_FAILURE);
+	}
+	fb = libgui_init("/dev/fb0");
+	if (fb == NULL) {
+		perror("libgui_init");
+		exit(EXIT_FAILURE);
+	}
+	// Turn off keyboard echoing.
+	echo_off();
+}
+
+void
+handle_key_input(void)
+{
+	if (fd < 0) {
+		return;
+	}
+
+	unsigned char scancode = 0;
+
+	if (read(fd, &scancode, 4) > 0) {
+		unsigned char keyRelease = (0x80 & scancode);
+
+		scancode = (0x7F & scancode);
+
+		if (0 == keyRelease) {
+			add_key_to_queue(1, scancode);
+		} else {
+			add_key_to_queue(0, scancode);
+		}
+	}
+}
+void
+DG_DrawFrame()
+{
+	for (uint32_t y = 0; y < DOOMGENERIC_RESY; y++) {
+		for (uint32_t x = 0; x < DOOMGENERIC_RESX; x++) {
+			libgui_pixel_write_ptr(fb, x, y,
+														 DG_ScreenBuffer[y * DOOMGENERIC_RESX + x]);
+		}
+	}
+	handle_key_input();
+}
+
+void
+DG_SleepMs(uint32_t ms)
+{
+	sleep(ms);
+}
+
+uint32_t
+DG_GetTicksMs()
+{
+	return uptime() - time_since_start;
+}
+
+int
+DG_GetKey(int *pressed, unsigned char *doomKey)
+{
+	if (s_KeyQueueReadIndex == s_KeyQueueWriteIndex) {
+		//key queue is empty
+		return 0;
+	} else {
+		unsigned short keyData = s_KeyQueue[s_KeyQueueReadIndex];
+		s_KeyQueueReadIndex++;
+		s_KeyQueueReadIndex %= KEYQUEUE_SIZE;
+
+		*pressed = keyData >> 8;
+		*doomKey = keyData & 0xFF;
+
+		return 1;
+	}
+
+	return 0;
+}
+
+void
+DG_SetWindowTitle(const char *title)
+{
+}
+
+static void
+echo_on(void)
+{
+	struct termios termios;
+	tcgetattr(STDIN_FILENO, &termios);
+	termios.c_lflag |= ECHO;
+	tcsetattr(STDIN_FILENO, TCSADRAIN, &termios);
+}
+
+static void
+echo_off(void)
+{
+	struct termios termios;
+	tcgetattr(STDIN_FILENO, &termios);
+	termios.c_lflag &= ~ECHO;
+	tcsetattr(STDIN_FILENO, TCSADRAIN, &termios);
+}
+
+int
+main(int argc, char **argv)
+{
+	doomgeneric_Create(argc, argv);
+
+	atexit(echo_on);
+	while (1) {
+		doomgeneric_Tick();
+	}
+
+	return 0;
+}
diff --git a/doomgeneric/Makefile b/doomgeneric/Makefile
index 503e0dc..0687f69 100644
--- a/doomgeneric/Makefile
+++ b/doomgeneric/Makefile
@@ -11,18 +11,22 @@ else
	VB=@
 endif

+ROOTDIR=$(shell pwd)/../../../../

-CC=clang  # gcc or g++
-CFLAGS+=-ggdb3 -Os
-LDFLAGS+=-Wl,--gc-sections
-CFLAGS+=-ggdb3 -Wall -DNORMALUNIX -DLINUX -DSNDSERV -D_DEFAULT_SOURCE # -DUSEASM
-LIBS+=-lm -lc -lX11
+CC=gcc  # gcc or g++
+CFLAGS+=-ggdb3 -O2
+LDFLAGS+=-Wl,--gc-sections -Wl,-z,noexecstack -Wl,-O1 -Wl,-N,-e,_start -Wl,--section-start=.text=0x1000
+CFLAGS+=-Wall -DNORMALUNIX -D_DEFAULT_SOURCE # -DUSEASM
+CFLAGS+=-pipe -fno-pic -static -fno-builtin -ffreestanding -nostdlib -nostdinc \
+				-mno-avx -I$(ROOTDIR)/include/ -I$(ROOTDIR) \
+				-D__USER__  -fno-stack-protector -include $(ROOTDIR)/include/math.h
+LIBS+= $(ROOTDIR)/bin/ulib.a $(ROOTDIR)/bin/libgui.a $(ROOTDIR)/bin/sharedlib.a

 # subdirectory for objects
 OBJDIR=build
 OUTPUT=doomgeneric

-SRC_DOOM = dummy.o am_map.o doomdef.o doomstat.o dstrings.o d_event.o d_items.o d_iwad.o d_loop.o d_main.o d_mode.o d_net.o f_finale.o f_wipe.o g_game.o hu_lib.o hu_stuff.o info.o i_cdmus.o i_endoom.o i_joystick.o i_scale.o i_sound.o i_system.o i_timer.o memio.o m_argv.o m_bbox.o m_cheat.o m_config.o m_controls.o m_fixed.o m_menu.o m_misc.o m_random.o p_ceilng.o p_doors.o p_enemy.o p_floor.o p_inter.o p_lights.o p_map.o p_maputl.o p_mobj.o p_plats.o p_pspr.o p_saveg.o p_setup.o p_sight.o p_spec.o p_switch.o p_telept.o p_tick.o p_user.o r_bsp.o r_data.o r_draw.o r_main.o r_plane.o r_segs.o r_sky.o r_things.o sha1.o sounds.o statdump.o st_lib.o st_stuff.o s_sound.o tables.o v_video.o wi_stuff.o w_checksum.o w_file.o w_main.o w_wad.o z_zone.o w_file_stdc.o i_input.o i_video.o doomgeneric.o doomgeneric_xlib.o
+SRC_DOOM = dummy.o am_map.o doomdef.o doomstat.o dstrings.o d_event.o d_items.o d_iwad.o d_loop.o d_main.o d_mode.o d_net.o f_finale.o f_wipe.o g_game.o hu_lib.o hu_stuff.o info.o i_cdmus.o i_endoom.o i_joystick.o i_scale.o i_sound.o i_system.o i_timer.o memio.o m_argv.o m_bbox.o m_cheat.o m_config.o m_controls.o m_fixed.o m_menu.o m_misc.o m_random.o p_ceilng.o p_doors.o p_enemy.o p_floor.o p_inter.o p_lights.o p_map.o p_maputl.o p_mobj.o p_plats.o p_pspr.o p_saveg.o p_setup.o p_sight.o p_spec.o p_switch.o p_telept.o p_tick.o p_user.o r_bsp.o r_data.o r_draw.o r_main.o r_plane.o r_segs.o r_sky.o r_things.o sha1.o sounds.o statdump.o st_lib.o st_stuff.o s_sound.o tables.o v_video.o wi_stuff.o w_checksum.o w_file.o w_main.o w_wad.o z_zone.o w_file_stdc.o i_input.o i_video.o doomgeneric.o doomgeneric_relix.o
 OBJS += $(addprefix $(OBJDIR)/, $(SRC_DOOM))

 all:	 $(OUTPUT)
diff --git a/doomgeneric/doomtype.h b/doomgeneric/doomtype.h
index a225c64..32c2349 100644
--- a/doomgeneric/doomtype.h
+++ b/doomgeneric/doomtype.h
@@ -15,7 +15,7 @@
 // DESCRIPTION:
 //	Simple basic typedefs, isolated here to make it easier
 //	 separating modules.
-//    
+//
 
 
 #ifndef __DOOMTYPE__
@@ -38,7 +38,7 @@
 
 
 //
-// The packed attribute forces structures to be packed into the minimum 
+// The packed attribute forces structures to be packed into the minimum
 // space necessary.  If this is not done, the compiler may align structure
 // fields differently to optimize memory access, inflating the overall
 // structure size.  It is important to use the packed attribute on certain
@@ -52,13 +52,13 @@
 #define PACKEDATTR
 #endif
 
-// C99 integer types; with gcc we just use this.  Other compilers 
+// C99 integer types; with gcc we just use this.  Other compilers
 // should add conditional statements that define the C99 types.
 
 // What is really wanted here is stdint.h; however, some old versions
-// of Solaris don't have stdint.h and only have inttypes.h (the 
-// pre-standardisation version).  inttypes.h is also in the C99 
-// standard and defined to include stdint.h, so include this. 
+// of Solaris don't have stdint.h and only have inttypes.h (the
+// pre-standardisation version).  inttypes.h is also in the C99
+// standard and defined to include stdint.h, so include this.
 
 #include <inttypes.h>
 
@@ -69,13 +69,12 @@
 typedef bool boolean;
 
 #else
-
-typedef enum 
+#include <stdbool.h>
+typedef int boolean;
+enum
 {
-    false	= 0,
-    true	= 1,
 	undef	= 0xFFFFFFFF
-} boolean;
+};
 
 #endif
 
diff --git a/doomgeneric/w_wad.c b/doomgeneric/w_wad.c
index 1248046..7630ca4 100644
--- a/doomgeneric/w_wad.c
+++ b/doomgeneric/w_wad.c
@@ -39,7 +39,7 @@
 typedef struct
 {
     // Should be "IWAD" or "PWAD".
-    char		identification[4];		
+    char		identification[4];
     int			numlumps;
     int			infotableofs;
 } PACKEDATTR wadinfo_t;
@@ -58,7 +58,7 @@ typedef struct
 
 // Location of each lump on disk.
 
-lumpinfo_t *lumpinfo;		
+lumpinfo_t *lumpinfo = NULL;
 unsigned int numlumps = 0;
 
 // Hash table for fast lookups
@@ -118,7 +118,10 @@ static void ExtendLumpInfo(int newnumlumps)
     }
 
     // All done.
-    free(lumpinfo);
+		if (lumpinfo != NULL)
+		{
+				free(lumpinfo);
+		}
     lumpinfo = newlumpinfo;
     numlumps = newnumlumps;
 }
@@ -179,7 +182,7 @@ wad_file_t *W_AddFile (char *filename)
 		M_ExtractFileBase (filename, fileinfo->name);
 		newnumlumps++;
     }
-    else 
+    else
     {
     	// WAD file
         W_Read(wad_file, 0, &header, sizeof(header));
@@ -263,11 +266,11 @@ int W_CheckNumForName (char* name)
     if (lumphash != NULL)
     {
         int hash;
-        
+
         // We do! Excellent.
 
         hash = W_LumpNameHash(name) % numlumps;
-        
+
         for (lump_p = lumphash[hash]; lump_p != NULL; lump_p = lump_p->next)
         {
             if (!strncasecmp(lump_p->name, name, 8))
@@ -275,11 +278,11 @@ int W_CheckNumForName (char* name)
                 return lump_p - lumpinfo;
             }
         }
-    } 
+    }
     else
     {
         // We don't have a hash table generate yet. Linear search :-(
-        // 
+        //
         // scan backwards so patch lump files take precedence
 
         for (i=numlumps-1; i >= 0; --i)
@@ -313,7 +316,7 @@ int W_GetNumForName (char* name)
     {
         I_Error ("W_GetNumForName: %s not found!", name);
     }
- 
+
     return i;
 }
 
@@ -343,22 +346,22 @@ void W_ReadLump(unsigned int lump, void *dest)
 {
     int c;
     lumpinfo_t *l;
-	
+
     if (lump >= numlumps)
     {
 	I_Error ("W_ReadLump: %i >= numlumps", lump);
     }
 
     l = lumpinfo+lump;
-	
+
     I_BeginRead ();
-	
+
     c = W_Read(l->wad_file, l->position, dest, l->size);
 
     if (c < l->size)
     {
 	I_Error ("W_ReadLump: only read %i of %i on lump %i",
-		 c, l->size, lump);	
+		 c, l->size, lump);
     }
 
     I_EndRead ();
@@ -374,7 +377,7 @@ void W_ReadLump(unsigned int lump, void *dest)
 // the lump data.
 //
 // 'tag' is the type of zone memory buffer to allocate for the lump
-// (usually PU_STATIC or PU_CACHE).  If the lump is loaded as 
+// (usually PU_STATIC or PU_CACHE).  If the lump is loaded as
 // PU_STATIC, it should be released back using W_ReleaseLumpNum
 // when no longer needed (do not use Z_ChangeTag).
 //
@@ -417,7 +420,7 @@ void *W_CacheLumpNum(int lumpnum, int tag)
 	W_ReadLump (lumpnum, lump->cache);
         result = lump->cache;
     }
-	
+
     return result;
 }
 
@@ -431,12 +434,12 @@ void *W_CacheLumpName(char *name, int tag)
     return W_CacheLumpNum(W_GetNumForName(name), tag);
 }
 
-// 
-// Release a lump back to the cache, so that it can be reused later 
+//
+// Release a lump back to the cache, so that it can be reused later
 // without having to read from disk again, or alternatively, discarded
 // if we run out of memory.
 //
-// Back in Vanilla Doom, this was just done using Z_ChangeTag 
+// Back in Vanilla Doom, this was just done using Z_ChangeTag
 // directly, but now that we have WAD mmap, things are a bit more
 // complicated ...
 //
@@ -484,10 +487,10 @@ void W_Profile (void)
     FILE*	f;
     int		j;
     char	name[9];
-	
-	
+
+
     for (i=0 ; i<numlumps ; i++)
-    {	
+    {
 	ptr = lumpinfo[i].cache;
 	if (!ptr)
 	{
