#include "autogenerated/compiler_information.h"

#include "boot/multiboot2.h"

#include "dev/acpi.h"
#include "dev/kbd.h"
#include "dev/lapic.h"
#include "dev/mouse.h"
#include "dev/null.h"
#include "dev/sd.h"

#include "bio.h"
#include "console.h"
#include "cpu.h"
#include "disk.h"
#include "file.h"
#include "ioapic.h"
#include "kalloc.h"
#include "kernel_assert.h"
#include "kernel_ld_syms.h"
#include "memlayout.h"
#include "mp.h"
#include "param.h"
#include "pci.h"
#include "picirq.h"
#include "proc.h"
#include "uart.h"
#include "vga.h"
#include "vm.h"
#include "x86.h"

#include <stdint.h>
#include <string.h>

static void startothers(void);
static void mpmain(void) __attribute__((noreturn));
extern uintptr_t *kpgdir;

int early_init;

uint64_t available_memory;
uint64_t top_memory;

int
main(struct multiboot_info *mbinfo)
{
	early_init = 1;
	/*-----------------------*\
	| uart-only printing zone |
	\*-----------------------*/
	uartinit1(); // serial port
	// 8MiB allocated just for the kernel.
	// This is to be considered an "early allocator".
	kinit1(__kernel_end, P2V(8 * MiB)); // phys page allocator
	parse_multiboot(mbinfo);
	kernel_assert(available_memory != 0);
	// Past kvmalloc, addresses need to be virtual.
	kvmalloc(); // kernel page table

	struct multiboot_tag_framebuffer *fb = get_multiboot_framebuffer();
	vga_init(fb);

	/*----------------------------------------------*\
	| We can start printing to the framebuffer here. |
	\*----------------------------------------------*/

	ioapicinit(); // another interrupt controller
	uartinit2();
	if (acpiinit() != 0) {
		mpinit(); // detect other processors
	}
	lapicinit(); // interrupt controller
	// After seginit, it's OK to call mycpu().
	seginit(); // segment descriptors
	picinit(); // disable pic
	vga_cprintf("relix (built with %s and linker %s)\n", RELIX_COMPILER,
	            RELIX_LINKER);
	dev_kbd_init();
	// /dev/console, not to be confused with VGA memory
	dev_console_init(); // console hardware
	dev_null_init();
	dev_mouse_init();
	dev_sd_init();
	pinit(); // process table
	block_init(); // buffer cache
	fileinit(); // file table
	disk_init();
	// timerinit();
	pci_init();
	startothers(); // start other processors
	early_init = 0;
	kinit2(P2V(8 * MiB), P2V(available_memory)); // must come after startothers()
	userinit(); // first user process
	mpmain(); // finish this processor's setup
}

// Other CPUs jump here from entryother.S.
void
mpenter(void)
{
	switchkvm();
	// After seginit, it's OK to call mycpu().
	seginit();
	lapicinit();
	mpmain();
}

// Common CPU setup code.
static void
mpmain(void)
{
	vga_cprintf("\033[97;44mcpu%d: starting\033[m\n", my_cpu_id());
	cpu_features_init();
	xchg(&(mycpu()->started), 1); // tell startothers() we're up
	scheduler(); // start running processes
}

void entry32mp(void);

// Start the non-boot (AP) processors.
static void
startothers(void)
{
	/* very strange:
	 * the value of this var is determined by the linker. It needs to be the full
	 * directory. _binary_[file_path]_start
	 * */
	extern uint8_t _binary_bin_entryother_start[], _binary_bin_entryother_size[];
	uint8_t *code;
	struct cpu *c;
	char *stack;

	struct {
		uint64_t s3;
		uint32_t s2;
		uint32_t s1;
	} intro_stack;

	// Write entry code to unused memory at 0x7000.
	// The linker has placed the image of entryother.S in
	// _binary_entryother_start.
	// Subtract sizeof(intro_stack) because
	// we need to store data below this.
	code = p2v(0x7000) - sizeof(intro_stack);
	memmove(code + sizeof(intro_stack), _binary_bin_entryother_start,
	        (uintptr_t)_binary_bin_entryother_size);

	for (c = cpus; c < cpus + ncpu; c++) {
		if (c == mycpu()) { // We've started already.
			continue;
		}

		// Tell entryother.S what stack to use, where to enter, and what
		// pgdir to use. We cannot use kpgdir yet, because the AP processor
		// is running in low  memory, so we use entrypgdir for the APs too.
		stack = kpage_alloc();

		// These are initialized in the order that
		// they are popped off the stack in lapicstartap.
		// In memory, they are in the reverse order due to
		// the stack growing down.
		intro_stack.s1 = 0x8000; // just enough stack to get us to entry64mp
		intro_stack.s2 = v2p(entry32mp);
		intro_stack.s3 = (uint64_t)(stack + KSTACKSIZE);

		memmove(code, &intro_stack, sizeof(intro_stack));
		// Put code pointer at the top of the stack.
		code += sizeof(intro_stack);

		lapicstartap(c->apicid, v2p(code));

		// wait for cpu to finish mpmain()
		while (c->started == 0)
			;
	}
}
